## 关于GPU的一些笔记

GPU(Graphics Processing Unit)图形处理单元,又称图形处理器,是显卡的核心部分,是显卡的心脏

GPU是专为复杂数学运算和几何运算而设计的芯片,处理能力比cpu强

从逻辑结构来看

cpu的组成有控制器(Control),算术逻辑单元(ALU),CPU内部缓存(Cache),与cpu运作相关的还有内存(DRAM),来支持很好的并行和串行操作,需要很强的通用性来处理各种不同的数据类型,同时又要执行复杂通用的逻辑判断,所以会引入大量的分支跳转和中断处理,这些都会是cpu内部结构异步复杂,计算单元的比重被降低了)

而gpu将==更多的空间==(晶体管)用作执行单元(密集的逻辑处理单元,所以适合对高密集的数据进行==并行处理==),因为gpu主要相对的==类型高度统一的,相互无依赖的大规模数据==和不需要打断的纯净环境,因此gpu的芯片相比cpu芯片简单很多,这也是为什么gpu运算能力很强的原因

而且GPU具有多个处理器核，在一个时刻可以并行处理多个数据，真正意义上实现了高并行

我们所说的GPU加速其实原理就是利用了GPU的高并行计算能力，比如我们在前端中利用GPU来处理复合图层（像素密集型）进行“加速”

GPU采用流式并行计算模式，可对每个数据进行独立的并行计算，所谓“对数据进行独立计算”，即，流内任意元素的计算不依赖于其它同类型数据.而所谓“并行计算”是指“多个数据可以同时被使用，多个数据并行运算的时间和1个数据单独执行的时间是一样的”。

### 如何在前端中应用GPU加速

前端页面的==渲染过程==

![前端页面的渲染过程](C:\Users\Administrator\Desktop\markdown笔记\GPU加速\images\1.png)

html标签经过(html解析器)二进制解析,语义化标签等构建成DOM Tree(在构建DOM树的过程中,遇到script标签会同步下载指定路径的文件,遇到link标签则是进行异步加载),css同样被CSS parser(css解析器)构建成CSSOM树,然后经过整合形成render Tree,然后进入layout阶段,这个阶段主要是计算元素大小与在屏幕的各个位置(计算位置也涉及到了浮动,绝对定义,粘性定位等),然后就会进入paint(绘制)阶段,这个阶段其实就是通过显卡将内容画到屏幕上

其实在paint阶段还有一个步骤-->Composite(渲染层合并)

![Composite渲染层](C:\Users\Administrator\Desktop\markdown笔记\GPU加速\images\3.png)

在Painting阶段，会调用引擎的paint api（canvas会调用draw api）进行像素级信息计算与绘制，像素级信息具体表现为帧信息（图层），浏览器会将各层的信息发送给GPU（GPU进程：最多一个，用于3D绘制等），GPU会将各层合成（composite），显示在屏幕上。

Composite阶段的作用:页面中 DOM 元素的绘制是在多个层上进行的。在每个层上完成绘制过程之后，浏览器会将所有层按照合理的顺序合并成一个图层，然后显示在屏幕上。对于有位置重叠的元素的页面，这个过程尤其重要，因为一旦图层的合并顺序出错，将会导致元素显示异常。

比较常见的回流(重新计算元素集合尺寸和位置)渲染流程(Layout和Paint步骤是可以避免的)

![常见的渲染流程](C:\Users\Administrator\Desktop\markdown笔记\GPU加速\images\4.jpg)

如上图,Layout阶段或者Paint阶段是可以避免的,但是DOM tree(重绘不用) 和 CSSOM tree, rendering tree不可避免

###### 关于render Tree一些问题

1. 不可见元素 比如 header 里的元素，比如 display:none;等元素在DOM树存在，但在渲染树不存在

2. 绝对定位的元素 比如，设置了position:absolute,fixed,float(浮动不是很确定,因为float并没有完全脱离文档流)的元素不会存在与渲染树中，会脱离一般的渲染流程。

###### 关于层的概念

![DOM树与layers树](C:\Users\Administrator\Desktop\markdown笔记\GPU加速\images\6.png)

结合浏览器的渲染过程可知,渲染树最终会转换为层树(Layer tree)

由上图可知,chrome(-webkit内核)有两种类型的层:

1. ==RenderLayers 渲染层 ===>负责对应的DOM子树的
2. ==GraphicsLayer 图像层== => 这是负责对应的RenderLayout子树

DOM树的每个节点都会对应一个LayoutObject,当它们的LayoutObject处于相同的坐标空间时,就会从此一个RenderLayers,也就是渲染层.

RenderLayers是用来保证页面元素以正确的顺序合成,然后出现了层合成(composite),从而正确处理透明元素和重叠元素的显示

有时,某些特殊的渲染层(RenderLayers)会被认为是合成层(Compositing Layers),合成层拥有单独的 GRaphicsLayer,而其他不是合成层的渲染层,则和器第一个拥有GraphicsLayer父层公用一个.

而每一个Graphicslayer(合成层单独拥有的图层),都有一个==GraphicsContex==t,这个GraphicsContext会负责输出该层的位图,而位图是存储在共享内存中,作为纹理上传到GPU中,最后由==GPU将多个位图进行合成==,然后显示到屏幕上

总结:GPU在前端在的应用 => 让需要复杂的动画元素(或所在元素)单独拥有一个合成图层

合成层的==优点==:

1. 合成层的位图,会交由GPU合成,比cpu处理快
2. 当需要repaint时,只需要repaint本身,不会影响到其他的层
3. 对于transform,opacity效果,不会触发layout和paint

如何变成合成层,==应用==GPU加速(硬件加速):

1. 3d或者透视变换(==perspective,transform==(这个主要是css3控制的Z轴的属性))的css属性
2. 使用加速视频解码```<vedio>```元素拥有3D
3. (WebGL)上下文或加速的2D上下文的```<canvas>```元素
4. 混合插件(如Flash)
5. 对自己的==opacity==做css动画或使用一个动画变化的元素
6. 元素由一个包含复合层的后代节点(也就说一个元素拥有一个子元素,而这个子元素在自己的层里，不是和很懂...)
7. 元素有一个==z-index==较低且包含一个复合层的兄弟元素(即改元素在复合层上渲染)

#### 注意事项:

1. 提升到合成层后,合成层的位图会交为GPU处理,但也只是合成的处理(即把会出的上下文位图输出进行组合)需要GPU,生成合成层的位图处理(绘图上下文的工作)还是需要cpu
2. 当需要repaint的时候,可以至repaint自身(层),不影响其他层,但是paint阶段前还有DOM树的构建,CSSOM树的构建,render tree的构建,layout阶段的计算各个元素的大小和位置,这里同样是占用时间(个人觉得,实际上合成层只是对于有3维效果的加上一个图层(合成层,类似于ps中的图层))
3. ==层爆炸风险== =>即由于某些原因可能产生大量不再预期内的合成层(简单理解就是,很多不需要提升为合成层的元素一位内某些不正当操作成为了合成层)
   - 解决方式:打破overlap条件,就是说让其他元素不要和合成层重叠 => 最直接的方式:使用3D硬件加速提升动画性能时,给元素增加一个z-index属性,属于认为干扰合成的顺序,可以有效减少创建不必要的合成层,提升渲染性能,移动端优化效果尤为明显